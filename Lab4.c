#include <stdio.h>
#include <stdlib.h> /* for exit */
#include <string.h>
#include <stdbool.h>
#include <math.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h> /* for ioctl */
#include <sys/mman.h> /* for mmap */
#include <sys/types.h>
#include <linux/fb.h> /* for fb_var_screeninfo, FBIOGET_VSCREENINFO */
#include <linux/input.h>
#include <wiringPi.h>

#define DEL 4
#define FBDEVFILE "/dev/fb2"
typedef unsigned char ubyte;
unsigned short makepixel(ubyte r, ubyte g, ubyte b) {
    return (unsigned short)(((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3));
}
#define MAX_PIXEL_SIZE 5

int C[24][50] = { {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };
int E[24][50] = { {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };
int F[24][50] = { {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,1,1,1,1,1,0,1,1,1,0,0,0,1,0,1,1,0,0,0,0},{0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,0},{0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,1,0,0},{0,1,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,1,0,0},{0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,1,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };
int fill[24][50] = { {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };
int L[24][50] = { {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };
int O[24][50] = { {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };
int P[24][50] = { {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };
int R[24][50] = { {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0},{0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0},{0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0},{0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0},{0,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,0},{0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,1,0,0},{0,0,1,0,0,1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0},{0,0,1,0,0,0,1,0,0,1,0,1,1,0,1,0,0,0,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,1,0,0,0,0,0,1,0,0,1,0,1,1,0,0,0},{0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,0,0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0},{0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0},{0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };
int S[24][50] = { {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };

typedef struct _Point {
    int x;
    int y;
}Point;

typedef struct listnode {
    int id;
    Point start;
    Point end;
    unsigned short linecolor;
    unsigned short fillcolor;
    struct listnode* link;
}listnode;

Point loc_s, loc_e;
listnode* temp;
Point Center;
bool total[196][196];
int selecting = 0;
int flag = 4;

unsigned short freedrawcolor;
float a, b, c, d, e, f, k;
unsigned short* pfbdata;
int rpixel;
int offset;
int fd, fbfd;
int finished = 0;
struct fb_var_screeninfo fbvar;
struct input_event ie;

int SX, SY, MX, MY = 0;
int fflag = 0;

void setCalibration() {
    int i, j, tt, pressure;
    int x[3], y[3], xd[3] = { 50, 150, 300 }, yd[3] = { 100, 50, 200 };
    unsigned short red = makepixel(255, 0, 0);
    for (tt = 0; tt < 3; tt++) {
        for (i = -5; i < 5; i++) {
            offset = (yd[tt] + i) * fbvar.xres + xd[tt];
            *(pfbdata + offset) = red;
            offset = yd[tt] * fbvar.xres + xd[tt] + i;
            *(pfbdata + offset) = red;
        }
        while (1) {
            read(fd, &ie, sizeof(struct input_event));
            if (ie.type == 3) {
                if (ie.code == 0) x[tt] = ie.value;
                else if (ie.code == 1) y[tt] = ie.value;
                else if (ie.code == 24) pressure = ie.value;
                if (pressure == 0)break;
            }
        }
        pressure = -1;
    }
    k = ((x[0] - x[2]) * (y[1] - y[2])) - ((x[1] - x[2]) * (y[0] - y[2]));
    a = ((xd[0] - xd[2]) * (y[1] - y[2])) - ((xd[1] - xd[2]) * (y[0] - y[2]));
    b = ((x[0] - x[2]) * (xd[1] - xd[2])) - ((xd[0] - xd[2]) * (x[1] - x[2]));
    c = (y[0] * ((x[2] * xd[1]) - (x[1] * xd[2]))) + (y[1] * ((x[0] * xd[2]) - (x[2] * xd[0]))) + (y[2] * ((x[1] * xd[0]) - (x[0] * xd[1])));
    d = ((yd[0] - yd[2]) * (y[1] - y[2])) - ((yd[1] - yd[2]) * (y[0] - y[2]));
    e = ((x[0] - x[2]) * (yd[1] - yd[2])) - ((yd[0] - yd[2]) * (x[1] - x[2]));
    f = (y[0] * ((x[2] * yd[1]) - (x[1] * yd[2]))) + (y[1] * ((x[0] * yd[2]) - (x[2] * yd[0]))) + (y[2] * ((x[1] * yd[0]) - (x[0] * yd[1])));
    a = a / k; b = b / k; c = c / k;
    d = d / k; e = e / k; f = f / k;
}

void blackscreen() {
    int i, j, tmp;
    printf("black screen\n");
    for (i = 0; i < 240; i++) {
        for (j = 0; j < 320; j++) {
            offset = i * 320 + j;
            *(pfbdata + offset) = 0;
        }
    }
}
void clearLcd(Point start, Point end) {
    int i, j, tmp;
    if (start.x > end.x) {
        tmp = start.x;
        start.x = end.x;
        end.x = tmp;
    }
    if (start.y > end.y) {
        tmp = start.y;
        start.y = end.y;
        end.y = tmp;
    }

    //printf("clear Lcd\n");
    unsigned short white = makepixel(255, 255, 255);
    for (i = start.y - 2; i < end.y + 2; i++) {
        for (j = start.x - 2; j < end.x + 2; j++) {

            if (i < 22 || i > 218 || j < 64 || j > 260)
            {
                continue;
            }
            offset = i * 320 + j;
            *(pfbdata + offset) = white;
        }
    }
}

listnode* insert_first(listnode* head, int id, Point start, Point end, unsigned short line, unsigned short f)
{
    listnode* p = (listnode*)malloc(sizeof(listnode));
    p->id = id;
    p->start.x = start.x;
    p->start.y = start.y;
    p->end.x = end.x;
    p->end.y = end.y;
    p->link = NULL;
    p->linecolor = line;
    p->fillcolor = f;
    head->link = p;
    return head;
}


listnode* Add(listnode* head, int id, Point start, Point end, unsigned short line, unsigned short f)
{
    if (head->link == NULL)
    {
        head = insert_first(head, id, start, end, line, f);
        return head;
    }
    listnode* cur = head->link;
    listnode* p = (listnode*)malloc(sizeof(listnode));
    p->id = id;
    p->start.x = start.x;
    p->start.y = start.y;
    p->end.x = end.x;
    p->end.y = end.y;
    p->link = NULL;
    p->linecolor = line;
    p->fillcolor = f;
    while (cur->link != NULL)
    {
        cur = cur->link;
    }
    cur->link = p; // 마지막에 추가
    return head;
}

void deleteAll(listnode* head)
{
    listnode* p = head->link;
    listnode* cur;
    for (; p != NULL; )
    {
        cur = p;
        p = p->link;
        head->link = p;
        printf("Memory return\n");
        free(cur);
    }
    free(head);
}

listnode* delete_first(listnode* head)
{
    listnode* removed;
    if (head->link == NULL) return NULL;
    //
    removed = head->link;
    head->link = removed->link;
    free(removed);
    return head;
}

listnode* delete(listnode* head, listnode* pre)
{
    listnode* removed;
    removed = pre->link;
    pre->link = removed->link;
    free(removed);
    return head;
}


int search_pixel(Point start, Point end, Point click) {
    int i, j;
    int c_x = (int)(end.x - start.x) / 2;
    int c_y = (int)(end.y - start.y) / 2;
    if ((abs(start.x + c_x - click.x) < MAX_PIXEL_SIZE) && (abs(start.y + c_y - click.y) < MAX_PIXEL_SIZE))
        return 1;
    return 0;
}

listnode* search_delete(listnode* head, Point click)
{
    listnode* p = head->link;
    listnode* pre = NULL;
    int i = 0;

    while (p != NULL) {
        i = search_pixel(p->start, p->end, click);
        if (i == 1) {
            if (pre == NULL) { head = delete_first(head); return head; }
            else { head = delete(head, pre); return head; }
        }
        pre = p;
        p = p->link;
    }
    return NULL;
}

void print_list(listnode* head)
{
    listnode* p = head->link;
    for (; p != NULL; p = p->link)
        printf("%d, %d / %d, %d \t", p->start.x, p->start.y, p->end.x, p->end.y);
    printf("NULL \n");
}

listnode* search(listnode* head, Point click)
{
    printf("In search function!!\n");
    listnode* p = head->link;
    //listnode* pre = NULL;
    int i = 0;
    while (p != NULL) {
        i = search_pixel(p->start, p->end, click);
        if (i == 1) {
            printf("Find!! \n");
            return p;
        }
        //pre = p;
        p = p->link;
    }
    return NULL;
}

void makeLineBox(Point start, Point end, unsigned short color, bool checkPen) {
    int i, j, tmp;
    if (start.x > end.x) {
        tmp = start.x;
        start.x = end.x;
        end.x = tmp;
    }
    if (start.y > end.y) {
        tmp = start.y;
        start.y = end.y;
        end.y = tmp;
    }
    if (checkPen) {
        for (j = start.x; j < end.x; j++) {
            if (start.y > 22 && start.y < 218 && j > 64 && j < 260)
            {
                offset = start.y * 320 + j;
                *(pfbdata + offset) = color;
            }
            if (end.y > 22 && end.y < 218 && j > 64 && j < 260) {
                offset = end.y * 320 + j;
                *(pfbdata + offset) = color;
            }
        }
        for (i = start.y; i < end.y; i++) {
            if (i > 22 && i < 218 && start.x > 64 && start.x < 260) {
                offset = i * 320 + start.x;
                *(pfbdata + offset) = color;
            }
            if (i > 22 && i < 218 && end.x > 64 && end.x < 260) {
                offset = i * 320 + end.x;
                *(pfbdata + offset) = color;
            }
        }
    }
    else {

        for (j = start.x + 1; j < end.x; j++) {
            for (i = start.y + 1; i < end.y; i++) {
                if (i < 22 || i > 218 || j < 64 || j > 260)
                {
                    continue;
                }
                offset = i * 320 + j;
                *(pfbdata + offset) = color;
            }
        }
    }
}
void makeLine(Point start, Point end, unsigned short color) {
    int i, j, tmp;
    float gradient = 0;
    if (end.x != start.x) gradient = (float)((float)(end.y - start.y) / (float)(end.x - start.x));
    float b = start.y - (gradient * start.x); //b = y-intercept

    if (end.x != start.x) {
        if (start.x < end.x) {
            for (j = start.x; j < end.x; j++) {
                i = gradient * j + b;
                if (i < 22 || i > 218 || j < 64 || j > 260)
                {
                    continue;
                }
                offset = i * 320 + j;
                *(pfbdata + offset) = color;
            }
        }
        else {
            for (j = start.x; j > end.x; j--) {
                i = gradient * j + b;
                if (i < 22 || i > 218 || j < 64 || j > 260)
                {
                    continue;
                }
                offset = i * 320 + j;
                *(pfbdata + offset) = color;
            }
        }
    }
    else {
        if (start.y < end.y) {
            for (i = start.y; i < end.y; i++) {
                if (i < 22 || i > 218 || start.x < 64 || start.x > 260)
                {
                    continue;
                }
                offset = i * 320 + start.x;
                *(pfbdata + offset) = color;
            }
        }
        else {
            for (i = start.y; i > end.y; i--) {
                if (i < 22 || i > 218 || start.x < 64 || start.x > 260)
                {
                    continue;
                }
                offset = i * 320 + start.x;
                *(pfbdata + offset) = color;
            }
        }
    }
}
void makeOval(Point start, Point end, unsigned short color, bool checkPen) {
    int i, j, tmp;
    if (start.x > end.x) {
        tmp = start.x;
        start.x = end.x;
        end.x = tmp;
    }
    if (start.y > end.y) {
        tmp = start.y;
        start.y = end.y;
        end.y = tmp;
    }

    // Elliptical equations were used.
    double a, b, tem_y;
    a = (end.x - start.x) / 2;
    b = (end.y - start.y) / 2;

    if (checkPen) {
        for (j = start.x; j < end.x; j++) {
            int OvalHeight = (int)sqrt(abs(pow(b, 2) * (1 - pow
            (j - start.x - a, 2) / pow(a, 2))));
            if ((int)(start.y + b - OvalHeight) > 22 && (int)(start.y + b - OvalHeight) < 218 && j > 64 && j < 260)
            {
                offset = (int)(start.y + b - OvalHeight) * 320 + j;
                *(pfbdata + offset) = color;
            }
            if ((int)(end.y - b + OvalHeight) > 22 && (int)(end.y - b + OvalHeight) < 218 && j > 64 && j < 260)
            {
                offset = (int)(end.y - b + OvalHeight) * 320 + j;
                *(pfbdata + offset) = color;
            }
        }
    }
    else {
        for (j = start.x; j < end.x; j++) {
            int OvalHeight = (int)sqrt(abs(pow(b, 2) * (1 - pow(j - start.x - a, 2) / pow(a, 2))));
            int k;
            for (k = 0; k < OvalHeight; k++) {
                if ((int)(start.y + b - k) > 22 && (int)(start.y + b - k) < 218&& j > 64 && j < 260) {
                    offset = (int)(start.y + b - k) * 320 + j;
                    *(pfbdata + offset) = color;
                }
                if ((int)(end.y - b + k) > 22 && (int)(end.y - b + k) < 218 && j> 64 && j < 260) {
                    offset = (int)(end.y - b + k) * 320 + j;
                    *(pfbdata + offset) = color;
                }
            }
        }
    }
}

void makefreeDraw(Point start, Point end, unsigned short color)
{
    int i, j;
    int delx, dely;
    int err = 0;
    int delerr = 0;
    int stepx, stepy;
    freedrawcolor = color;
    Point _start;
    Point _end;
    delx = end.x - start.x;
    dely = end.y - start.y;

    if (delx < 0)
    {
        delx = -delx;
        stepx = -1;
    }
    else stepx = 1;

    if (dely < 0)
    {
        dely = -dely;
        stepy = -1;
    }
    else stepy = 1;
    if (delx > dely)
    {
        delerr = dely << 1;
        i = start.y;
        for (j = start.x; j != end.x; j += stepx) {
            total[i - 22][j - 64] = true;
            offset = i * 320 + j;
            *(pfbdata + offset) = color;
            err += delerr;
            if (err >= delx)
            {
                i += stepy;
                err -= delx << 1;
            }
        }
        total[i - 22][j - 64] = true;
        offset = i * 320 + j;
        *(pfbdata + offset) = color;
    }
    else {
        delerr = delx << 1;
        j = start.x;
        for (i = start.y; i != end.y; i += stepy) {
            total[i - 22][j - 64] = true;
            offset = i * 320 + j;
            *(pfbdata + offset) = color;
            err += delerr;
            if (err >= dely)
            {
                j += stepx;
                err -= dely << 1;
            }
        }
        total[i - 22][j - 64] = true;
        offset = i * 320 + j;
        *(pfbdata + offset) = color;
    }

    if (end.x > MX) MX = end.x;
    if (end.y > MY) MY = end.y;
    if (end.x < SX) SX = end.x;
    if (end.x < SY) SY = end.y;
}
int selection(listnode* head, Point click, unsigned short color, bool checkPen)
{
    int i, j, tmp, type;

    int dx, dy;
    Point Change;
    unsigned short white = makepixel(255, 255, 255);

    if (selecting == 0)
    {
        Center.x = click.x;
        Center.y = click.y;
        printf("Center.x : %d\n", Center.x);
        printf("Center.y : %d\n", Center.y);
        temp = search(head, Center);
        // click 한 위치의 객체 반환 , 객체 중앙을 클릭해야함
        if (temp == NULL) {
            printf("Cannot Found!! \n");
            return -1;
        }
        selecting = 1;
    }
    else {
        int type = temp->id;
        unsigned short temp_line = temp->linecolor;
        unsigned short temp_fill = temp->fillcolor;
       
        
        Change.x = click.x;
        Change.y = click.y;

        dx = (Change.x - Center.x);
        dy = (Change.y - Center.y);

        loc_s = temp->start;
        loc_e = temp->end;
        loc_s.x += dx; loc_e.x += dx;
        loc_s.y += dy; loc_e.y += dy;
        // Board : 64, 22, 260, 218

        switch (type)
        {
        case 1:
            makeLine(loc_s, loc_e, color);

            break;
        case 2:
            if(temp_fill != white) makeLineBox(loc_s, loc_e, temp_fill, false);
            makeLineBox(loc_s, loc_e, temp_line, true);
            break;
        case 3:
            if(temp_fill != white) makeOval(loc_s, loc_e, temp_fill, false);
            makeOval(loc_s, loc_e, temp_line, true);
            break;
        }
        delay(100);
        clearLcd(loc_s, loc_e);

    }
    return 1;
}


void makecolorBox(int stx, int sty, int enx, int eny, unsigned short color)
{
    int i, j;
    for (i = sty; i < eny; i++) {               // 240
        for (j = stx; j < enx; j++) {           // 320
            offset = i * 320 + j;
            *(pfbdata + offset) = color;
        }
    }
}

void makecharBox(int stx, int sty, int enx, int eny, int c[][50])
{
    int i, j;
    unsigned short black = makepixel(0, 0, 0);
    for (i = sty; i < eny; i++) {
        for (j = stx; j < enx; j++) {
            if (c[i - sty][j - stx] == 1) {
                offset = i * 320 + j;
                *(pfbdata + offset) = black;
            }
        }
    }
}

void clear_and_print(listnode* head)
{
    if (head->link == NULL) return;
    int i, j;
    unsigned short black = makepixel(0, 0, 0);
    Point start, end;
    start.x = 64;
    start.y = 22;
    end.x = 260;
    end.y = 218;

    unsigned short white = makepixel(255, 255, 255);
    for (i = start.y; i < end.y; i++) {
        for (j = start.x; j < end.x; j++) {

            if (i < 22 || i > 218 || j < 64 || j > 260)
            {
                continue;
            }
            if (total[i - start.y][j - start.x] == true) continue;
            offset = i * 320 + j;
            *(pfbdata + offset) = white;
        }
    }

    listnode* p = head->link;
    for (; p != NULL; p = p->link)
    {
        unsigned short temp_line;
        unsigned short temp_fill;
        temp_line = p->linecolor;
        temp_fill = p->fillcolor;
        if (p->id == 1)
        {
            makeLine(p->start, p->end, temp_line);
        }
        else if (p->id == 2)
        {
            makeLineBox(p->start, p->end, temp_line, true);
            if(temp_fill != white) makeLineBox(p->start, p->end, temp_fill, false);
        }
        else if (p->id == 3)
        {
            makeOval(p->start, p->end, temp_line, true);
            if(temp_fill != white) makeOval(p->start, p->end, temp_fill, false);
        }

        printf("%d, %d / %d, %d \n", p->start.x, p->start.y, p->end.x, p->end.y);
    }
    for (i = 0; i < 196; i++)
    {
        for (j = 0; j < 196; j++)
        {
            if (total[i][j] == true)
            {
                offset = (i + 22) * 320 + (j + 64);
                *(pfbdata + offset) = freedrawcolor;
            }
        }
    }

    return;

}

void setting()
{
    unsigned short white = makepixel(255, 255, 255);
    unsigned short orange = makepixel(255, 127, 39);
    unsigned short red = makepixel(255, 0, 0);
    unsigned short green = makepixel(146, 208, 80);
    unsigned short yellow = makepixel(255, 255, 0);
    unsigned short navy = makepixel(0, 32, 96);
    unsigned short blue = makepixel(0, 112, 192);
    unsigned short black = makepixel(0, 0, 0);
    unsigned short back = makepixel(0, 128, 64);

    makecolorBox(0, 0, 320, 240, back);              // 바탕 화면
    makecolorBox(9, 22, 59, 46, white);              // Line
    makecolorBox(9, 50, 59, 74, white);              // Rect
    makecolorBox(9, 78, 59, 102, white);              // Oval
    makecolorBox(9, 106, 59, 130, white);              // Free_draw
    makecolorBox(9, 134, 59, 158, white);              // Select
    makecolorBox(9, 162, 59, 186, white);              // Erase
    makecolorBox(9, 190, 59, 214, white);              // Clear
    makecolorBox(64, 22, 260, 218, white);              // Board
    makecolorBox(265, 162, 315, 186, white);              // Pen
    makecolorBox(265, 190, 315, 214, white);              // Fill

    // colorbox
    makecolorBox(265, 22, 287, 42, white);
    makecolorBox(293, 22, 315, 42, orange);
    makecolorBox(265, 48, 287, 68, red);
    makecolorBox(293, 48, 315, 68, green);
    makecolorBox(265, 74, 287, 94, yellow);
    makecolorBox(293, 74, 315, 94, navy);
    makecolorBox(265, 100, 287, 120, blue);
    makecolorBox(293, 100, 315, 120, black);

    makecharBox(9, 22, 59, 46, L);              // Line
    makecharBox(9, 50, 59, 74, R);              // Rect
    makecharBox(9, 78, 59, 102, O);              // Oval
    makecharBox(9, 106, 59, 130, F);              // Free_draw
    makecharBox(9, 134, 59, 158, S);              // Select
    makecharBox(9, 162, 59, 186, E);              // Erase
    makecharBox(9, 190, 59, 214, C);              // Clear
    makecharBox(265, 162, 315, 186, P);              // Pen
    makecharBox(265, 190, 315, 214, fill);              // Fill
}

listnode* Fill(listnode* head, Point click, unsigned short currentcolor, bool checkPen) {
    printf("Fill start! \n");
    int filled_id;
    listnode* filled = NULL;
    // int pen = true;

    filled = search(head, click);
    if (filled == NULL) {
        printf("Cannot Found! \n");
        return head;
    }
    else {
        filled_id = filled->id;
        filled->fillcolor = currentcolor;
        if (filled_id == 2) {
            makeLineBox(filled->start, filled->end, currentcolor, false);
        }
        else if (filled_id == 3) {
            makeOval(filled->start, filled->end, currentcolor, false);
        }
        return head;
    }
}
listnode* Erase(listnode* head, Point click)
{
    unsigned short white = makepixel(255, 255, 255);

    Point start, end;
    start.x = 64;
    start.y = 22;
    end.x = 260;
    end.y = 218;


    printf("Erase start! \n");
    int delete_id;
    int pen = true;
    listnode* delete = NULL;

    int i, j;

    delete = search(head, click);
    if (delete == NULL) {
        if (total[click.y - start.y][click.x - start.x] == true) {
            printf("Erase free draw! \n");
            for (i = start.y; i < end.y; i++) {
                for (j = start.x; j < end.x; j++) {
                    if (total[i - start.y][j - start.x] == true)
                    {
                        offset = i * 320 + j;
                        *(pfbdata + offset) = white;
                    }
                }
            }
            memset(total, false, sizeof(total));
            //clear_and_print(head);
            if(head->link != NULL) clear_and_print(head);
            printf("Delete Successful \n");
            return head;
        }
        else {
            printf("Cannot Found! \n");
            return NULL;
        }
    }
    else {
        delete_id = delete->id;
        if (delete_id == 1) {
            makeLine(delete->start, delete->end, white);
            head = search_delete(head, click);
            if (head->link != NULL) clear_and_print(head);
            printf("Line Delete Successful \n");
            return head;
        }
        else if (delete_id == 2) {
            makeLineBox(delete->start, delete->end, white, true);
            makeLineBox(delete->start, delete->end, white, false);
            head = search_delete(head, click);
            if (head->link != NULL) clear_and_print(head);
            printf("Rectangle Delete Successful \n");
            return head;
        }
        else if (delete_id == 3) {
            makeOval(delete->start, delete->end, white, true);
            makeOval(delete->start, delete->end, white, false);
            head = search_delete(head, click);
            if (head->link != NULL) clear_and_print(head);
            printf("Oval Delete Successful \n");
            return head;
        }
        else if (delete_id == 4) {
            makeLineBox(delete->start, delete->end, white, true);
            makeLineBox(delete->start, delete->end, white, false);
            head = search_delete(head, click);
            if (head->link != NULL) clear_and_print(head);
            printf("Delete Successful \n");
            return head;
        }
    }
}

int main()
{
    unsigned short white = makepixel(255, 255, 255);
    unsigned short orange = makepixel(255, 127, 39);
    unsigned short red = makepixel(255, 0, 0);
    unsigned short green = makepixel(146, 208, 80);
    unsigned short yellow = makepixel(255, 255, 0);
    unsigned short navy = makepixel(0, 32, 96);
    unsigned short blue = makepixel(0, 112, 192);
    unsigned short black = makepixel(0, 0, 0);
    int pressure = -1;
    int ret, t, i, j;
    Point get, start, end;
    unsigned short currentcolor = black;
    unsigned short Linecolor=black, Backcolor; //add : default black 
    bool checkPen = true;


    int x1, x2, y1, y2;
    fbfd = open(FBDEVFILE, O_RDWR);

    if (fbfd < 0) {
        perror("fbdev open");
        exit(1);
    }
    ret = ioctl(fbfd, FBIOGET_VSCREENINFO, &fbvar);
    if (ret < 0) {
        perror("fbdev ioctl");
        exit(1);
    }
    if (fbvar.bits_per_pixel != 16) {
        fprintf(stderr, "bpp is not 16\n");
        exit(1);
    }

    pfbdata = (unsigned short*)mmap(0, fbvar.xres * fbvar.yres * 16 / 8, PROT_READ | PROT_WRITE, MAP_SHARED, fbfd, 0);
    if ((unsigned)pfbdata == (unsigned)-1) {
        perror("fbdev mmap");
        exit(1);
    }
    memset(total, false, sizeof(total));
    fd = open("/dev/input/event4", O_RDONLY);
    if (fd < 0) return -1;
    printf("start\n");
    blackscreen();
    setCalibration();
    blackscreen();


    setting();

    listnode* head = (listnode*)malloc(sizeof(listnode));
    head->link = NULL;
    //listnode* head = NULL;

    while (1)
    {
        start.x = 0; start.y = 0; end.x = 0; end.y = 0;
        while (1) {
            //clear_and_print(head);
            read(fd, &ie, sizeof(struct input_event));
            if (ie.type == 3) {
                if (ie.code == 0) {
                    get.x = ie.value;
                }
                else if (ie.code == 1) {
                    get.y = ie.value;
                }
                else if (ie.code == 24) {
                    pressure = ie.value;
                    end.x = a * get.x + b * get.y + c;
                    end.y = d * get.x + e * get.y + f;
                    if (end.x > 9 && end.y > 22 && end.x < 59 && end.y < 46)
                    {
                        flag = 1; // Line
                        printf("click flag : %d\n", flag);
                    }
                    else if (end.x > 9 && end.y > 50 && end.x < 59 && end.y < 74)
                    {
                        flag = 2; // Rect
                        printf("click flag : %d\n", flag);
                    }
                    else if (end.x > 9 && end.y > 78 && end.x < 59 && end.y < 102)
                    {
                        flag = 3; // Rect
                        printf("click flag : %d\n", flag);
                    }
                    else if (end.x > 9 && end.y > 106 && end.x < 59 && end.y < 130)
                    {
                        flag = 4; // Free_draw
                        printf("click flag : %d\n", flag);
                    }
                    else if (end.x > 9 && end.y > 134 && end.x < 59 && end.y < 158)
                    {
                        flag = 5; // Rect
                        printf("click flag : %d\n", flag);
                    }
                    else if (end.x > 9 && end.y > 162 && end.x < 59 && end.y < 186)
                    {
                        flag = 6; // Erase
                        printf("click flag : %d\n", flag);
                    }
                    else if (end.x > 9 && end.y > 190 && end.x < 59 && end.y < 214)
                    {
                        flag = 7; // Clear
                        printf("click flag : %d\n", flag);
                        Point __a, __b;
                        __a.x = 64;
                        __a.y = 22;
                        __b.x = 260;
                        __b.y = 218;
                        clearLcd(__a, __b);
                        deleteAll(head);
                        head = (listnode*)malloc(sizeof(listnode));
                        head->link = NULL;
                        flag = 4;
                        memset(total, false, sizeof(total));
                        break;
                    }
                    else if (end.x > 265 && end.y > 162 && end.x < 315 && end.y < 186)
                    {
                        checkPen = true;  Linecolor = currentcolor;
                        flag = 8; // Pen
                        break;
                    }
                    else if (end.x > 265 && end.y > 190 && end.x < 315 && end.y < 214)
                    {
                        checkPen = false; Backcolor = currentcolor; 
                        flag = 9; // Fill
                        break;
                    }
                    else if (end.x > 265 && end.y > 22 && end.x < 287 && end.y < 42) {
                        currentcolor = white; 
                        if(checkPen) Linecolor = currentcolor; 
                        else Backcolor = currentcolor;
                    }
                    else if (end.x > 293 && end.y > 22 && end.x < 315 && end.y < 42) {
                        currentcolor = orange; 
                        if(checkPen) Linecolor = currentcolor; 
                        else Backcolor = currentcolor;
                    }
                    else if (end.x > 265 && end.y > 48 && end.x < 287 && end.y < 68) {
                        currentcolor = red;
                        if(checkPen) Linecolor = currentcolor; 
                        else Backcolor = currentcolor;
                    }
                    else if (end.x > 293 && end.y > 48 && end.x < 315 && end.y < 68) {
                        currentcolor = green; 
                        if(checkPen) Linecolor = currentcolor; 
                        else Backcolor = currentcolor;
                    }
                    else if (end.x > 265 && end.y > 74 && end.x < 287 && end.y < 94) {
                        currentcolor = yellow;
                        if(checkPen) Linecolor = currentcolor; 
                        else Backcolor = currentcolor;
                    }
                    else if (end.x > 293 && end.y > 74 && end.x < 315 && end.y < 94) {
                        currentcolor = navy;
                        if(checkPen) Linecolor = currentcolor; 
                        else Backcolor = currentcolor;
                    }
                    else if (end.x > 265 && end.y > 100 && end.x < 287 && end.y < 120) {
                        currentcolor = blue;
                        if(checkPen) Linecolor = currentcolor; 
                        else Backcolor = currentcolor;
                    }
                    else if (end.x > 293 && end.y > 100 && end.x < 315 && end.y < 120) {
                        currentcolor = black;
                        if(checkPen) Linecolor = currentcolor; 
                        else Backcolor = currentcolor;
                    }
                    else if (end.x > 64 && end.y > 22 && end.x < 260 && end.y < 218)
                    {
                        if (flag == 1)
                        {
                            if (start.x == 0 && start.y == 0)
                            {
                                start.x = end.x;
                                start.y = end.y;
                                continue;
                            }
                            clearLcd(start, end); //add
							makeLine(start, end, currentcolor); delay(100); //add
                            if (pressure == 0) {
                                if (start.x != end.x || start.y != end.y)
                                {
                                    makeLine(start, end, currentcolor);
                                    head = Add(head, 1, start, end, currentcolor, white);
                                    if (head->link != NULL) clear_and_print(head);
                                    //clear_and_print(head);
                                    break;
                                }
                            }
                        }
                        else if (flag == 2)
                        {
                            if (start.x == 0 && start.y == 0)
                            {
                                start.x = end.x;
                                start.y = end.y;
                            }

                            clearLcd(start, end);
                            makeLineBox(start, end, currentcolor, checkPen); delay(100);

                            if (pressure == 0) {
                                if(checkPen)
                                head = Add(head, 2, start, end, Linecolor, white);
                                else
                                head = Add(head, 2, start, end, Backcolor, Backcolor);
                                if (head->link != NULL) clear_and_print(head);
                                //clear_and_print(head);
                                break;
                            }
                        }
                        else if (flag == 3)  // oval
                        {
                            if (start.x == 0 && start.y == 0)
                            {
                                start.x = end.x;
                                start.y = end.y;
                            }
                            clearLcd(start, end);
                            makeOval(start, end, currentcolor, checkPen); delay(100);
                            if (pressure == 0) {
                                if(checkPen)
                                head = Add(head, 3, start, end, Linecolor, white);
                                else
                                head = Add(head, 3, start, end, Backcolor, Backcolor);
                                if (head->link != NULL) clear_and_print(head);
                                //clear_and_print(head);
                                break;
                            }
                        }
                        else if (flag == 4)  // free draw
                        {
                            if (fflag == 0) {
                                start.x = a * get.x + b * get.y + c;
                                start.y = d * get.x + e * get.y + f;
                                fflag = 1;
                            }
                            end.x = a * get.x + b * get.y + c;
                            end.y = d * get.x + e * get.y + f;
                            makefreeDraw(start, end, currentcolor);
                            start.x = end.x;
                            start.y = end.y;
                            if (pressure == 0) {
                                fflag = 0;
                                break;
                            }
                        }
                        else if (flag == 5)  // select 
                        {
                            Point param;
                            param.x = end.x;
                            param.y = end.y;
                            int value;
                            value = selection(head, param, currentcolor, checkPen);
                            if (value == -1)
                            {
                                selecting = 0;
                                continue;

                                //다시 선택해라
                            }
                            selecting = 1;
                            if (pressure == 0) {
                                selecting = 0;
                                temp->start = loc_s;
                                temp->end = loc_e;
                                if (temp->id == 1)
                                {
                                    makeLine(loc_s, loc_e, currentcolor);
                                }
                                else if (temp->id == 2)
                                {
                                    makeLineBox(loc_s, loc_e, currentcolor, checkPen);
                                }
                                else if (temp->id == 3)
                                {
                                    makeOval(loc_s, loc_e, currentcolor, checkPen);
                                }
		                        clear_and_print(head);
                                break;
                            }
                        }
                        else if (flag == 6)
                        {
                            // erase 박스 범위시 실행
                            Point param;
                            param.x = end.x;
                            param.y = end.y;
                            listnode* test;
                            test = Erase(head, param);
                            if (test == NULL)
                            {
                                continue;
                            }
                            for (i = 0; i < 196; i++)
                            {
                                for (j = 0; j < 196; j++)
                                {
                                    if (total[i][j] == true)
                                    {
                                        offset = (i + 22) * 320 + (j + 64);
                                        *(pfbdata + offset) = freedrawcolor;
                                    }
                                }
                            }
                            head = test;
		                    //clear_and_print(head);

                        }
                        else if (flag == 9)
                        {
                            Point param;
                            param.x = end.x;
                            param.y = end.y;
                            head = Fill(head, param, Backcolor, checkPen);
                        }
                    }
                    //
                }
            }
        }
        if (finished == 1)
        {
            break;
        }
    }

    close(fd);
    close(fbfd);
    return 0;
}
